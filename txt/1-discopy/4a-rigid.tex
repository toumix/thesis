%!TEX root = ../../THESIS.tex

\subsection{Rigid categories \& wire bending} \label{subsection:rigid}

In sections~\ref{section:cat} and \ref{section:monoidal} we discussed the fundamental notion of \emph{adjunction} with the example of free-forgetful functors.
The definition of left and right adjoints in terms of unit and counit natural transformations makes sense in $\mathbf{Cat}$, but it can be translated in the context of any monoidal category $C$.
An object $x^l \in C_0$ is the left adjoint of $x \in C_0$ whenever there are two arrows $\ttcup(x) : x^l \otimes x \to 1$ and $\ttcap(x) : 1 \to x \otimes x^l$ (also called counit and unit) such that:
\begin{itemize}
\item $\ttcap(x) \otimes x \ \fcmp \ x \otimes \ttcup(x) \s = \s \id(x)$,
\ctikzfig{img/rigid/snake-left}
\item $x^l \otimes \ttcap(x) \ \fcmp \ \ttcup(x) \otimes x^l \s = \s \id(x^l)$.
\ctikzfig{img/rigid/snake-right}
\end{itemize}
This is equivalent to the condition that the functor $x^l \otimes - : C \to C$ is the left adjoint of $x \otimes - : C \to C$.
Symmetrically, $x^r \in C_0$ is the right-adjoint of $x \in C_0$ if $x$ is its left adjoint.
We say that $C$ is \emph{rigid} (also called \emph{autonomous}) if every object has a left and right adjoint.
From this definition we can deduce a number of properties:
\begin{itemize}
    \item adjoints are unique up to isomorphism,
    \item adjoints are monoid anti-homomorphisms, i.e. $(x \otimes y)^l \simeq y^l \otimes x^l$ and $1^l \simeq 1$,
    \item left and right adjoints cancel, i.e. $(x^l)^r \simeq x \simeq (x^r)^l$,
\end{itemize}
We say that $C$ is strictly rigid whenever these isomorphisms are in fact equalities, again one can show that any rigid category is monoidally equivalent to a strict one.
One can also show that cups and caps compose by nesting:
\begin{itemize}
\item $\ttcup(x \otimes y) \s = \s y^l \otimes \ttcup(x) \otimes y \ \fcmp \ \ttcup(y)$,
\ctikzfig{img/rigid/nesting-cups}
\item $\ttcap(x \otimes y) \s = \s \ttcap(x) \ \fcmp \ x \otimes \ttcap(y) \otimes x^l$,
\ctikzfig{img/rigid/nesting-caps}
\item $\ttcup(1) \s = \s \ttcap(1) \s = \s \id(1)$, drawn as the equality of three empty diagrams.
\end{itemize}
The first two equations are drawn as diagrams in a non-foo monoidal category, i.e. with wires for composite types and explicit boxes for tensor.
This can be taken as an inductive definition, once we have defined the cups and caps for generating objects, we have defined them for all types.
Thus, we can take the data for a (strictly) rigid category $C$ to be that of a free-on-objects monoidal category together with:
\begin{itemize}
    \item a pair of unary operators $(-)^l, (-)^r : C_0 \to C_0$ on generating objects,
    \item and a pair of functions $\ttcup, \ttcap : C_0 \to C_1$ witnessing that $x^l$ and $x^r$ are the left and right adjoints of each generating object $x \in C_0$.
\end{itemize}
Diagrams in rigid categories are more flexible than monoidal categories: we can bend wires.
They owe their name to the fact that they are less flexible than \emph{pivotal categories}.
For any rigid category $C$, there are two contravariant endofunctors, called the left and right \emph{transpose} respectively.
They send objects to their left and right adjoints, and each arrow $f : x \to y$ to
\begin{center}
\tikzfig{img/rigid/transpose-left}
\hspace{50pt} and \hspace{50pt}
\tikzfig{img/rigid/transpose-right}
\end{center}
A rigid category $C$ is called \emph{pivotal} when it has a monoidal natural isomorphism $x^l \sim x^r$ for each object $x$, which implies that the left and right transpose coincide: we can rotate diagrams by 360 degrees.
We say $C$ is strictly piotal when this isomorphism is an equality.
This is the case for any rigid category $C$ with a dagger structure: the dagger of the cup (cap) for an object $x$ is the cap (cup) of its left-adjoint $x^l$.
When this is the case, $C$ is called $\dagger$-pivotal.
We say $C$ is strictly piotal when left and right transpose are equal.

\begin{example}
Recall from example~\ref{example:endofunctors are monoidal} that for any category $C$, the category $C^C$ of endofunctors and natural transformations is monoidal.
Its subcategory with endofunctors that have both left and right adjoints is rigid.
Its subcategory with endofunctors that have equal left and right adjoints is pivotal.
\end{example}

\begin{example}
$\mathbf{Tensor}_\S$ is $\dagger$-pivotal with left and right adjoints given by list reversal, cups and caps by the Kronecker delta $\ttcup(n)(i, j) = \ttcap(n)(i, j) = 1$ if $i = j$ else $0$.
Note that for tensors of order greater than 2, the \emph{diagrammatic transpose} defined in this way differs from the usual \emph{algebraic transpose}: the former reverses list order while the latter is the identity on objects.
\end{example}

\begin{example}
$\mathbf{Circ}$ is $\dagger$-pivotal with the preparation of the Bell state as cap and the post-selected Bell measurement as cup (both are scaled by $\sqrt{2}$).
The snake equations yield a proof of correctness for the (post-selected) quantum teleportation protocol.
\end{example}

\begin{example}\label{example:pregroups}
A discrete rigid category is a group: if the cups and caps are identities then they define an inverse for the tensor.
A rigid preordered monoid (i.e. a rigid category with at most one arrow between any two objects) is called a (quasi\footnote
{In his original definition~\cite{Lambek99}, Lambek also requires that pregroups are \emph{partial orders}, i.e. preorders with antisymmetry $x \leq y$ and $y \leq x$ implies $x = y$.
This implies that pregroups are strictly rigid, but also that they cannot be free on objects: $\ttcup(x) \otimes \id(x) : x \otimes x^l \otimes x \to x$ and $\id(x) \otimes \ttcap(x) : x \to x \otimes x^l \otimes x$ together would imply $x = x \otimes x^l \otimes x$.
}) \emph{pregroup}, their application to NLP will be discussed in section~\ref{section:NLP}.
A commutative pregroup is a (preordered) abelian group: left and right adjoints coincide with the multiplicative inverse.

Natural examples of non-free non-commutative pregroups are hard to come by.
One exception is the monoid of \emph{monotone unbounded functions} $\Z \to \Z$ with composition as multiplication and pointwise order.
The left adjoint of $f : \Z \to \Z$ is defined such that $f^l(m)$ is the minimum $n \in \Z$ with $m \leq f(n)$ and symmetrically $f^r(m)$ is the maximum $n \in \N$ with $f(n) \leq m$.
Extending Cayley's theorem from groups to pregroups, Buszkowski~\cite[Proposition~2]{Buszkowski01} proved that every pregroup $G$ is in fact isomorphic to a subpregroup (i.e. a monoidal subcategory) of monotone functions $G \to G$.
\end{example}

Any monoidal functor $F : C \to D$ between two rigid categories $C$ and $D$ preserves left and right adjoints up to isomorphism, we say it is strict when it preserves them up to equality.
Thus, we have defined a subcategory $\mathbf{RigidCat} \injects \mathbf{MonCat}$.
We define a \emph{rigid signature} $\Sigma$ as a monoidal signature where the generating objects have the form $\Sigma_0 \times \Z$.
We identify $x \in \Sigma_0$ with $(x, 0) \in \Sigma_0 \times \Z$ and define the left and right adjoints $(x, z)^l = (x, z - 1)$ and $(x, z)^r = (x, z + 1)$.
The objects $\Sigma_0$ are called \emph{basic types}, their iterated adjoints $\Sigma_0 \times \Z$ are called \emph{simple types}.
The integer $z \in \Z$ is called the \emph{adjunction number} of the simple type $(x, z) \in \Sigma_0 \times \Z$ by Lambek and Preller~\cite{PrellerLambek07} and its \emph{winding number} by Joyal and Street~\cite{JoyalStreet88}.
Again, a morphism of rigid signatures $f : \Sigma \to \Gamma$ is a pair of functions $f : \Sigma_0 \to \Gamma_0$ and $f : \Sigma_1 \to \Gamma_1$ which commute with domain and codomain.

There is a forgetful functor $U : \mathbf{RigidCat} \to \mathbf{RigidSig}$ which sends any strictly-rigid foo-monoidal category to its underlying rigid signature.
We now describe its left-adjoint $F^r : \mathbf{RigidSig} \to \mathbf{RigidCat}$.
Given a rigid signature $\Sigma$, we define a monoidal signature $\Sigma^r = \Sigma \cup \{ \ttcup (x) \}_{x \in \Sigma_0} \cup \{ \ttcap (x) \}_{x \in \Sigma_0}$.
The free rigid category is the quotient $F^r(\Sigma) = F(\Sigma^r) / R$ of the free monoidal category by the snake equations $R$.
That is, the objects are lists of simple types $(\Sigma_0 \times \Z)^\star$, the arrows are equivalence classes of diagrams with cup and cap boxes.
This is implemented in the \py{rigid} module of DisCoPy as outlined below.

\begin{python}
{\normalfont Implementation of objects and types of free rigid categories.}

\begin{minted}{python}
@dataclass
class Ob(cat.Ob):
    z: int

    l = property(lambda self: Ob(self.name, self.z - 1))
    r = property(lambda self: Ob(self.name, self.z + 1))

    @classmethod
    def cast(cls, old: cat.Ob) -> Ob:
        return old if isinstance(old, cls) else cls(str(old), z=0)

class Ty(monoidal.Ty, Ob):
    def __init__(self, inside=[]):
        monoidal.Ty.__init__(self, inside=map(Ob.cast, inside))

    l = property(lambda self: self.cast(Ty(*[x.l for x in self.inside[::-1]])))
    r = property(lambda self: self.cast(Ty(*[x.r for x in self.inside[::-1]])))
\end{minted}
\end{python}

\begin{example}
We can check the axioms for objects in rigid categories hold on the nose.

\begin{minted}{python}
x, y = Ty('x'), Ty('y')
assert Ty().l == Ty() == Ty().r
assert (x @ y).l == y.l @ x.l and (x @ y).r == y.r @ x.r
assert x.r.l == x == x.l.r
\end{minted}
\end{example}

\py{rigid.Ob} and \py{rigid.Ty} are implemented as subclasses of \py{cat.Ob} and \py{monoidal.Ty} respectively, with \py{property} methods (i.e. attributes that are computed on the fly) \py{l} and \py{r} for the left and right adjoints.
Thanks to the \py{cast} method, we do not need to override the \py{tensor} method inherited from \py{monoidal.Ty}.
In turn, subclasses of \py{rigid.Ty} will not need to override \py{l} and \py{r}.
Similarly, the \py{rigid.Diagram} class is a subclass of \py{monoidal.Diagram}, thanks to the \py{cast} we do not need to reimplement the identity, composition or tensor.
\py{rigid.Box} is a subclass of \py{monoidal.Box} and \py{rigid.Diagram}, with \py{Box.cast = Diagram.cast}.
We need to be careful with the order of inheritance however, diagram equality is defined in terms of box equality, so if we had \py{Box.__eq__ = Diagram.__eq__} then checking equality would enter an infinite loop.
\py{Cup} (\py{Cap}) is a subclass of \py{Box} initialised by a pair of types \py{x, y} such that \py{len(x) == len(y) == 1} \py{x == y.l} (\py{x.l == y}, respectively).
The class methods \py{cups} and \py{caps} construct diagrams of nested cups and caps by induction, with \py{Cup} and \py{Cap} as a base case.

\begin{python}
{\normalfont Implementation of the arrows of free rigid categories.}

\begin{minted}{python}
class Diagram(monoidal.Diagram):
    def transpose(self, left=True) -> Diagram:
        if left: ... # Symmetric to the right case.
        return self.caps(self.dom.r, self.dom) @ self.id(self.cod.r)\
            >> self.id(self.dom.r) @ self @ self.id(self.cod.r)\
            >> self.id(self.dom.r) @ self.cups(self.cod, self.cod.r)

class Box(monoidal.Box, Diagram):
    cast = Diagram.cast

class Cup(Box):
    def __init__(self, x: Ty, y: Ty):
        assert len(x) == 1 and x == y.l
        super().__init__("Cup({}, {})".format(x, y), x @ y, Ty())

class Cap(Box):
    def __init__(self, x: Ty, y: Ty):
        assert len(x) == 1 and x.l == y
        super().__init__("Cap({}, {})".format(x, y), Ty(), x @ y)

def nesting(factory):
    @classmethod
    def method(cls, x: Ty, y: Ty) -> Diagram:
        if len(x) == 0: return cls.id(Ty())
        if len(x) == 1: return factory(x, y)
        head = factory(x[0], y[-1])
        if head.dom:  # We are nesting cups.
            return x[0] @ method(x[1:], y[:-1]) @ y[-1] >> head
        return head >> x[0] @ method(x[1:], y[:-1]) @ y[-1]
    return method

Diagram.cups, Diagram.caps = nesting(Cup), nesting(Cap)
\end{minted}
\end{python}

The \emph{snake removal} algorithm listed below computes the normal form of diagrams in rigid categories.
It is a concrete implementation of the abstract algorithm described in pictures by Dunn and Vicary~\cite[2.12]{DunnVicary19}.
First, we implement a subroutine \py{follow_wire} takes a codomain node (given by the index \py{i} of its box and the index \py{j} of itself in the box's codomain)
follows the wire till it finds either the domain of another box or the codomain of the diagram.
When we follow a wire, we compute two lists of \emph{obstructions}, the index of each box on its left and right.
The \py{find_snake} function calls \py{follow_wire} for each \py{Cap} in the diagram until it finds one that is connected to a \py{Cup}, or returns \py{None} otherwise.
A \py{Yankable} snake is given by the index of its cup and cap, the two lists of obstructions on each side and whether it is a left or right snake.
\py{unsnake} applies \py{interchange} repeatedly to remove the obstructions, i.e. to make the cup and cap consecutive boxes in the diagram, then returns the diagram with the snake removed.
Each snake removed reduces the length $n$ of the diagram by 2, hence the \py{snake_removal} algorithm makes at most $n / 2$ calls to \py{find_snake}.
Finally, we call \py{monoidal.Diagram.normal_form} which takes at most cubic time.
Finding a snake takes quadratic time (for each cap we need to follow the wire at each layer) as well as removing it (for each obstruction we make a linear number of calls to \py{interchange}).
Thus, we can compute normal forms for diagrams in free rigid categories in cubic time.
We conjecture that we can in fact solve the word problem (i.e. deciding whether two diagrams are equal) in quadratic time using the same reduction to planar map isomorphism as in theorem~\ref{theorem:monoidal-normal-form}.

\begin{python}\label{listing:snake-removal}
{\normalfont Outline of the snake removal algorithm.}

\begin{minted}{python}
Obstruction = tuple[tuple[int, ...], tuple[int, ...]]
Yankable = tuple[int, int, Obstruction, bool]

def follow_wire(self: Diagram, i: int, j: int) -> tuple[int, int, Obstruction]: ...
def find_snake(self: Diagram) -> Optional[Yankable]: ...
def unsnake(self: Diagram, yankable: Yankable) -> Diagram: ...
def snake_removal(self: Diagram) -> Diagram:
    yankable = find_snake(diagram)
    return snake_removal(unsnake(diagram, yankable)) if yankable else diagram

Diagram.normal_form = lambda self:\
    monoidal.Diagram.normal_form(snake_removal(self))
\end{minted}
\end{python}

\begin{example}
We can check that the snake equations hold up to normal form.

\begin{minted}{python}
t = x @ y

left_snake = Diagram.id(t.l).transpose(left=False)
right_snake = Diagram.id(t).transpose(left=True)

assert left_snake.normal_form() == Diagram.id(t)\
    and right_snake.normal_form() == Diagram.id(t.l)

drawing.equation(
    drawing.Equation(left_snake, Diagram.id(t)),
    drawing.Equation(right_snake, Diagram.id(t.l)),
    symbol='and', space=2, draw_type_labels=False)
\end{minted}

\ctikzfig{img/rigid/double-snake-equation}
\end{example}

\begin{example}
We can check that left and right transpose cancel up to normal form.

\begin{minted}{python}
f = Box('f', x, y)

left_right_transpose = f.transpose(left=True).transpose(left=False)
right_left_transpose = f.transpose(left=False).transpose(left=True)

assert left_right_transpose.normal_form() == f == right_left_transpose.normal_form()
drawing.equation(left_right_transpose, f, right_left_transpose)
\end{minted}

\ctikzfig{img/rigid/transpose-inverse}
\end{example}

\begin{python}\label{example:pivotal-circuit}
{\normalfont Implementation of $\mathbf{Circ}$ as a pivotal category.}

\begin{minted}{python}
class Qubits(monoidal.Qubits, Ty):
    l = r = property(lambda self: self)

class Circuit(monoidal.Circuit, Diagram):
    cups = nesting(lambda _, _: sqrt2 @ Ket(0, 0) >> H @ qubit)
    caps = lambda x, y: Circuit.cups(x, y).dagger()
\end{minted}
\end{python}

\begin{example}
We can verify the teleportation protocol for two qubits.

\begin{minted}{python}
two_qubit_Bell_state = Circuit.caps(qubit ** 2)
two_qubit_Bell_effect = Circuit.cups(qubit ** 2)

assert (two_qubit_Bell_state @ qubit ** 2 >> qubit ** 2 @ two_qubit_Bell_effect).eval()\
    == (qubit ** 2).eval()\
    == (qubit ** 2 @ two_qubit_Bell_state >> two_qubit_Bell_effect @ qubit ** 2).eval()
\end{minted}
\end{example}

\py{rigid.Functor} is implemented as a subclass of \py{monoidal.Functor} with the \py{__call__} method overriden.
The image on types and on objects \py{x} with \py{x.z == 0} remains unchanged.
The image on objects \py{x} with \py{x.z < 0} is defined by \py{F(x) = F(x.r).l} and symmetrically for \py{x.z > 0}.
Indeed, when defining a strict rigid functor we only need to define the image of basic types, the image of their iterated adjoints is completely determined.
The only problem arises when the objects in the codomain do not have \py{l} and \py{r} attributes, such as the implementation of $\mathbf{Tensor}_\S$ with \py{list[int]} as objects.
In this case, we assume that the left and right adjoints are given by list reversal.

\begin{python}
{\normalfont Implementation of strict rigid functors.}
\begin{minted}{python}
class Functor(monoidal.Functor):
    dom = cod = Category(Ty, Diagram)

    def __call__(self, other):
        if isinstance(other, Ty) or isinstance(other, Ob) and other.z == 0:
            return super().__call__(other)
        if isinstance(other, Ob):
            if not hasattr(self.cod.ob, 'l' if other.z < 0 else 'r'):
                return self(Ob(other.name, z=0))[::-1]
            return self(other.r).l if other.z < 0 else self(other.l).r
        if isinstance(other, Cup):
            return self.cod.ar.cups(self(other.dom[:1]), self(other.dom[1:]))
        if isinstance(other, Cap):
            return self.cod.ar.caps(self(other.dom[:1]), self(other.dom[1:]))
        return super().__call__(other)
\end{minted}
\end{python}

\begin{python}
{\normalfont Implementation of $\mathbf{Tensor}_\S$ as a pivotal category.}
\begin{minted}{python}
Tensor.cups = classmethod(lambda cls, x, y: cls(cls.id(x).inside, x + y, []))
Tensor.caps = classmethod(lambda cls, x, y: cls(cls.id(x).inside, [], x + y))
\end{minted}
\end{python}

\begin{example}
We can check that $\mathbf{Tensor}_\S$ is indeed pivotal.

\begin{minted}{python}
F = Functor(
    ob={x: 2, y: 3}, ar={f: [[1, 2, 3], [4, 5, 6]]}
    cod=Category(tuple[int, ...], Tensor[int]))

assert F(left_snake) == F(Diagram.id(x)) == F(right_snake)
assert F(f.transpose(left=True)) == F(f).transpose() == F(f.transpose(left=False))

# Diagrammatic and algebraic transpose differ for tensors of order >= 2.
assert F(f @ f).transpose() != F((f @ f).transpose())
\end{minted}
\end{example}

Free pivotal categories are defined in a similar way to free rigid categories, with the two-element field $\Z / 2 \Z$ instead of the integers $\Z$, i.e. simple types with adjunction numbers of the same parity are equal.
In this case, we usually write $x^l = x^r = x^\star$ with $(x^\star)^\star = x$.
Given a pivotal signature $\Sigma$ with objects of the form $\Sigma_0 \times (\Z / 2 \Z)$, the free pivotal category is the quotient $F^p(\Sigma) = F^r(\Sigma) / R$ of the free rigid category by the relation $R$ equating the left and right transpose of the identity for each generating object.
While the diagrams of free rigid categories can have snakes, those of free pivotal categories can have circles: we can compose $\ttcap(x) : 1 \to x^l \otimes x$ then $\ttcup(x^\star) : x^l \otimes x \to 1$ to form a scalar diagram called the \emph{dimension} of the system $x$.
We also draw the wires with an orientation: the wire for $x$ is labeled with an arrow going down, the one for $x^\star$ with an arrow going up.

To the best of our knowledge, the word problem for pivotal categories is still open.
When defining the normal form of pivotal diagrams, we would need to make a choice between the diagrams for left or right transpose of a box.
Another solution is to add a new box $f^T : y^\star \to x^\star$ for the transpose of every box $f : x \to y$ in the signature, and set it as the normal form of both diagrams.
We can add some asymmetry to the drawing of the box $f$, and draw $f^T$ as its 180Â° degree rotation.
If the category is also $\dagger$-pivotal, we get a four-fold symmetry: the box, its dagger, its transpose and its dagger-transpose (also called its conjugate).
This is still being developed by the DisCoPy community.

\begin{python}
{\normalfont Implementation of free $\dagger$-pivotal categories.}

\begin{minted}{python}
class Ob(rigid.Ob):
    l = r = property(lambda self: self.cast(Ob(self.name, (self.z + 1) % 2)))

class Ty(rigid.Ty, Ob):
    def __init__(self, inside=[]):
        rigid.Ty.__init__(self, inside=map(Ob.cast, inside))

class Diagram(rigid.Diagram): pass

class Box(rigid.Box, Diagram):
    cast = Diagram.cast

class Cup(rigid.Cup, Box):
    def dagger(self):
        return Cap(self.dom[0], self.dom[1])

class Cap(rigid.Cap, Box):
    def dagger(self):
        return Cup(self.cod[0], self.cod[1])

Diagram.cups, Diagram.caps = nesting(Cup), nesting(Cap)

class Functor(rigid.Functor):
    dom = cod = Category(Ty, Diagram)
\end{minted}
\end{python}
